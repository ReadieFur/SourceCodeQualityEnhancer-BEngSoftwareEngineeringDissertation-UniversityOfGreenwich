\subsubsection{Language features}
The language features module provides automation for updating code to support new language specific features. Currently, this module contains support for features such as inferred access modifiers and the implicit object initialization syntax that was introduced in C\# 9.0.

\subsubsubsection{Inferred access modifiers}
In C\#, when a top level class or struct is declared, it is assigned a default access modifier of \texttt{internal}, while any nested declarations within the class or struct are assigned a default access modifier of \texttt{private}. For both of these instances an explicit access modifier can be provided to override the default. Using implicit access modifiers can reduce the amount of code written ever so slightly. To many it is likely not known what the default access modifiers are, so by providing the option to require explicit access modifiers, it can help to improve the readability of the codebase by making it clear what the access modifier is for a given declaration.
The sub-module will be triggered for all object declaration syntax. For all declaration syntax that is passed to the sub-module, a check is run to determine what modifiers the node has. If the node is missing access modifiers a diagnostic is created and returned to the user with an automated code fix. The code fix will insert the missing access modifier into the list of modifiers for the node. The access modifier to be inserted is determined by the level of the node and if the node is a top level node the access modifier will be \texttt{internal}, while if the node is a nested node the access modifier will be \texttt{private}. A node is considered top-level if it is within a document that is not using top-level statements or if the parent of the node is a namespace declaration.

\subsubsubsection{Implicit object initialization}
Introduced in C\# 9.0, the implicit object initialization syntax allows for the omission of the object type when initializing an object whose underlying type is already known at compile-time. This can help to reduce the amount of code written and can help to improve readability by reducing the amount of boilerplate code that is written. For example, prior to C\# 9.0, to initialize a new object one would have to write \texttt{var obj = new MyObject();}. With the new syntax one can write \texttt{MyObject obj = new();}.
If enabled, the sub-module will be triggered for all object creation expressions. Unlike the previous modules in this tool, the AST cannot be worked on directly as context of the compilation is needed to determine the type of the object that is being created. Therefore, the compilation event provided is hooked by the Roslyn API. From this context we checks are made for any object creation expressions. On these expressions there are two ways that the underlying type can be determined: the first is by checking if the object creation expression belongs to a variable declaration; and the second is by checking if the object creation expression is being assigned to a variable.
For the former case, it is rather easy to determine if the object is being assigned to a new variable as the parent of the object creation expression can be checked to see if it is a variable declaration and if it is then it can be checked to see if the expression is being assigned to a \texttt{var} keyword or a type. If it is being assigned to a \texttt{var} keyword then the type of the object can be determined by checking the type of the variable declaration. For the latter case, the parent object is also assessed, though what the parent object is can vary significantly. Take the example of a method call: the object creation expression is a child of the method call. In this instance the definition of the method call with the relevant overload that the object creation expression is being assigned to needs to be found. Once the method call is found via the compilation context, is it necessary to acquire the index of the argument that the object creation expression is being assigned to, and from this index the type of the object that is being created can be determined.
Once the type of the object is determined, the sub-modules code fix provider will either convert the object creation expression to or from the implicit object initialization syntax. When converting to the implicit syntax the type of assignment must be checked again and if the object creation expression is being assigned to a \texttt{var} keyword, the code fix will convert the object creation expression to the implicit syntax and replace the \texttt{var} keyword with the explicit type of the object. This has the added benefit of cleaning up the declarations in the program as while the \texttt{var} can reduce the amount of code written for variable declarations, it can often be misleading due to the variable type not being known to the programmer without searching through the code to see what is being assigned to it in order to determine the variable type. Likewise, if the module is configured to not allow implicit object initialization, the code fix will convert the implicit object initialization syntax to the explicit syntax and insert the type of the object.

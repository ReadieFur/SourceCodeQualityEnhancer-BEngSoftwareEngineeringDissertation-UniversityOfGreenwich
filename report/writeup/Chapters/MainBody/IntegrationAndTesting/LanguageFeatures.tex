\subsubsection{Language features}
The language features module provides automation for updating code to support new language specific features. Currently this module contains support for features such as inferred access modifiers and the implicit object initialization syntax that was introduced in C\# 9.0.

\subsubsubsection{Inferred access modifiers}
In C\#, when a top level class or struct is declared, it is assigned a default access modifier of \texttt{internal}, any nested declarations within the class or struct are assigned a default access modifier of \texttt{private}. For both of these instances an explicit access modifier can be provided to override the default. While using implicit access modifiers can reduce the amount of code written ever so slightly. To many it is likely not known what the default access modifiers are, so by providing the option to require explicit access modifiers, it can help to improve the readability of the codebase by making it clear what the access modifier is for a given declaration.
The sub-module will be triggered for all object declaration syntax. For all declaration syntax that is passed to the sub-module, a check is run to determine what modifiers the node has, if the node is missing access modifiers a diagnostic is created and returned to the user with an automated code fix. The code fix will insert the missing access modifier into the list of modifiers for the node. The access modifier to be inserted is determined by the level of the node, if the node is a top level node the access modifier will be \texttt{internal}, if the node is a nested node the access modifier will be \texttt{private}. A node is considered top-level if it is within a document that is not using top-level statements or if the parent of the node is a namespace declaration.

\subsubsubsection{Implicit object initialization}
Introduced in C\# 9.0, the implicit object initialization syntax allows for the omission of the object type when initializing an object who's underlying type is already known at compile-time. This can help to reduce the amount of code written and can help to improve readability by reducing the amount of boilerplate code that is written, for example, prior to C\# 9.0, to initialize a new object you would have to write \texttt{var obj = new MyObject();}, with the new syntax you can write \texttt{MyObject obj = new();}.
If enabled, the sub-module will be triggered for all object creation expressions. Unlike the previous modules in this tool, we cannot work on the AST directly as we need context of the compilation to determine the type of the object that is being created, therefore we instead hook to the compilation event provided by the Roslyn API. From this context we check for any object creation expressions, on these expressions there are two ways that the underlying type can be determined, the first is by checking if the object creation expression belongs to a variable declaration, and the second is by checking if the object creation expression is being assigned to a variable.
For the former case, it is rather easy to determine if the object is being assigned to a new variable as we can check the parent of the object creation expression to see if it is a variable declaration, if it is then we check to see if the expression is being assigned to a \texttt{var} keyword or a type, if it is being assigned to a \texttt{var} keyword we can determine the type of the object by checking the type of the variable declaration. For the latter case, the parent object is also assessed, though what the parent object is can vary significantly, take the example of a method call, the object creation expression is a child of the method call, in this instance we need to find the definition of the method call with the relevant overload that the object creation expression is being assigned to. Once the method call is found via the compilation context, we must acquire the index of the argument that the object creation expression is being assigned to, from this index we can determine the type of the object that is being created.
Once the type of the object is determined, the sub-modules code fix provider will either convert the object creation expression to or from the implicit object initialization syntax. When converting to the implicit syntax the type of assignment must be checked again, if the object creation expression is being assigned to a \texttt{var} keyword, the code fix will convert the object creation expression to the implicit syntax and replace the \texttt{var} keyword with the explicit type of the object. This has the added benefit of cleaning up the declarations in the program as while the \texttt{var} can reduce the amount of code written for variable declarations, it can often be misleading due to the variable type not being known to the programmer without searching through the code to see what is being assigned to it in order to determine the variable type. Likewise if the module is configured to not allow implicit object initialization, the code fix will convert the implicit object initialization syntax to the explicit syntax and insert the type of the object.

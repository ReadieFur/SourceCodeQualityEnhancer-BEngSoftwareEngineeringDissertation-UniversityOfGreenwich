\subsubsection{User defined configuration}

\begin{wrapfigure}{r}{0.5\textwidth}
    \centering
    \caption{YAML Schema}
    \label{fig:YAMLSchema}
    \includegraphics[width=0.5\textwidth]{Figures/YAMLSchemaCropped.png}
\end{wrapfigure}

As discussed in the literature review, due to the lack of standardization in code formatting, the tool should be able to be configured by the user. This is achieved through the use of a YAML configuration file, as configuration parsing isn't the goal of this work, the well-known, open source YAML parsing library YamlDotNet was used, this library is under the MIT license which grants us full permission to use the library in this project.

YAML was chosen as the configuration language due to its human readability, it is very easy to implement and understand by the end user. A custom schema was created for the configuration to aid the user in creating the configuration file by providing IDE hints and validation on their configuration (see figure \ref{fig:YAMLSchema}).

\begin{wrapfigure}{r}{0.4\textwidth}
    \centering
    \caption{YAML Configuration}
    \label{fig:YAMLConfiguration}
    \includegraphics[width=0.4\textwidth]{Figures/YAMLConfigurationCropped.png}
\end{wrapfigure}

Like in the program, the configuration is split up into multiple sections, each section corresponds to a different module in the program with each module having a wide range of configuration options to allow for fine tuning of the program. In Figure \ref{fig:YAMLConfiguration} we can see an example of a configuration file, in the visible snippet the configuration for the custom naming engine is shown. Each module inherits from a base set of rules that allow the user to either enable or disable a module, and set the severity of the issue that the module is checking for. By default, all modules are disabled and the severity is set to info. Depending on how strict you may want the work environment to be, you can set the severity to cause an error which will result in not allowing the program to compile, this can be beneficial in a large team where you want to enforce a strict code style to improve readability and maintainability of the codebase.

The configuration file is loaded into the program at runtime, when the configuration is loaded varies by the implementing program. Due to the limitations of certain platforms, the configuration class is been created as a partial class that inherits from an interface where the configuration loader can be tweaked depending on the platform it is being compiled for. The configuration class is implemented as a singleton, this is because the code parser that is being used works in a static context, where configuration is loaded once and only once. This does have the downside of meaning any changes that the user wants to make to the configuration will require a restart of the program, this is a limitation of the Roslyn API and is not something that can easily be worked around.

\begin{wrapfigure}{r}{0.4\textwidth}
    \centering
    \caption{VSIX Configuration manager}
    \label{fig:VSIXConfigurationManager}
    \includegraphics[width=0.4\textwidth]{Figures/VSIXAConfigManagerCropped.png}
\end{wrapfigure}

Taking the configuration implementation from the VSIX project as an example, the configuration is loaded when the extension is loaded into the IDE, the configuration also has to get loaded into a separate process that Visual Studio launches to run code analysis. This inherently caused a problem as it was discovered through debugging that the child-process does not have the context of the loaded workspace and so the user-defined configuration would not be found. To work around this issue, a shared memory space is setup between the two processes to allow for communication of the configuration to be shared (see figure \ref{fig:VSIXConfigurationManager}).
